---
title: "Lb_1_Tsukaiev"
output: html_document
date: "2024-11-12"
---

# Зміст
- [Функції select(), rename_with() і relocate()](#функції-select-rename_with-і-relocate)
- [Функція across()](#функція-across)
- [Функція rowwise()](#функція-rowwise)
- [Функція summarise()](#функція-summarise)
- [Аргумент rows_*()](#аргумент-rows_)
- [Висновки](#висновки)

## Функції select(), rename_with() і relocate()

```{r, message=FALSE}
#Підключаємо пакет dplyr.
library(dplyr)
```

```{r}
#Для прикладу ми будемо використовувати вбудований набір даних iris.
tibble(iris)

#Виконаємо такі дії:
# 1. Вибираємо всі стовпці, які закінчуються на Width.
select(iris, ends_with("Width")) %>% tibble()

# 2. Переміщюємо за допомогою функції relocate() єдиний текстовий стовпець у ліву частину таблиці.
relocate(iris, Species) %>% tibble()

# 3. Заміняємо за допомогою функції rename_with() у назві стовпців точку на нижнє підкреслення і перетворюємо імена на нижній регістр.
rename_with(iris, ~ gsub("\\.", "_", .x) %>% tolower()) %>% tibble()
```

## Функція across()

```{r}
#Як і в попередньому розділі виконувати завдання будемо на таблиці iris.
tibble(iris)

#Виконаємо такі дії:
# 1. Використовуючи функцію across(), розділяємо значення полів, імена яких закінчуються на Length на середнє значення по цим же стовпцям.
iris %>% mutate(across(ends_with("Length"), ~ .x / mean(.x))) %>% tibble()

# 2. Порахуйємо середнє значення стовпців, імена яких починаються на Sepal, згрупувавши дані по стовпцю Species.
iris %>% group_by(Species) %>% summarise(across(starts_with("Sepal"), mean))
```

## Функція rowwise()

```{r}
#На цей раз тестові дані для виконання завдань ми генеруватимемо самостійно, використовуючи наведений нижче код.
set.seed(400)
year <- 2000:2005
sales <- sapply(
  month.abb, 
  FUN = function(x) round(runif(n = 6, min = 100, max = 400), 0)
  )

sales <- as.data.frame(sales, row.names = year)
sales$year <- year
sales
```

```{r}
#Наше завдання не перевертаючи таблицю, додати до неї 4 стовпці:

#winter_avg_sales - середній обсяг продажу за зимові місяці;
#spring_avg_sales – середній обсяг продажів за весняні місяці;
#summer_avg_sales – середній обсяг продажів за літні місяці;
#autumn_avg_sales – середній обсяг продажів за осінні місяці;
#І залишити з вихідної таблиці лише стовпець із позначенням року, та розраховані на попередньому кроці стовпці.

#Код для виконання завдання буде виглядати таким чином:
sales %>% rowwise() %>% mutate(winter_avg_sales = mean(c(Jan, Feb, Dec)), spring_avg_sales = mean(c(Mar, Apr, May)), summer_avg_sales = mean(c(Jun, Jul, Aug)), autumn_avg_sales = mean(c(Sep, Oct, Nov))) %>% select(year, winter_avg_sales, spring_avg_sales, summer_avg_sales, autumn_avg_sales)
```

## Функція summarise()

```{r}
#Підключаємо пакет tidyr.
library(tidyr)
```

```{r}
#Нам дано таблицю параметрів генерації випадкової вибірки з нормальним розподілом (генерувати випадкову вибірку з нормальним розподілом дозволяє функція rnorm()).

#Для створення таблиці параметрів виконаємо наступний код:
params <- tribble(
  ~sim, ~n, ~mean, ~sd,
  1,  4,     1,   5,
  2,  7,     2,   10,
  3, 10,   -1,   25
)
```

```{r}
# Тепер згенеруйте згідно з цими параметрами таблицю, яка містить у стовпці sim номер рядка таблиці параметрів, а в стовпці val самі значення випадкових розподілів. Для відтворення результатів встановимо лічильник генерації випадкових чисел в позиції 400.
set.seed(400)

#  Тоді код підсумкового результату матиме такий вигляд:
params %>% group_by(sim) %>% summarise(val = list(rnorm(n, mean, sd))) %>% unnest(cols = c(val))
```

## Аргумент rows_*()

```{r}
# Цього разу нам необхідно буде розрахувати зарплатню 6 співробітників.

# Для отримання тестових даних виконаємо наведений нижче приклад коду:

# Зарплатна відомість зі ставками від бухгалтерії
salary <- tibble(
  employee_id = 1:5,
  rate        = c(1000, 1200, 700, 1500, 2000),
  bonus       = rep(0, 5),
  penalty     = rep(0, 5)
)

# Бонуси від керівників відділів
bonus <- tibble(
  employee_id = c(3, 5),
  bonus = c(100, 500)
)

# Штрафи від керівників відділів
penalty <- tibble(
  employee_id = c(1, 4, 5),
  penalty = c(150, 320, 80)
)

# Внесення нового співробітника у відомість
new <- tibble(
  employee_id = 6,
  rate = 500,
  bonus = 0,
  penalty = 0
)

# Коригування ставки за фактично виробленим часом
time_rate <- tibble(
  employee_id = 1:6, 
  time_rate = c(1, 1, 1, 0.8, 1, 0.5)
)
```

```{r}
# В результаті ви сформували 5 таблиць:

#salary - зарплатна відомість від бухгалтерії, бухгалтерія знає лише дані про ставки співробітників;
```

```{r, echo = FALSE}
salary
```

```{r}
#bonus – бонуси, які виписали керівники відділів співробітникам;
```

```{r, echo = FALSE}
bonus
```

```{r}
#penalty – штрафи, які виписали керівники відділів;
```

```{r, echo = FALSE}
penalty
```

```{r}
#new - таблиця з 6 співробітником, він новачок і бухгалтерія забула внести його одразу до основної відомості;
```

```{r, echo = FALSE}
new
```

```{r}
#time_rate - дані про фактично відпрацьований час співробітника за місяць.
```

```{r, echo = FALSE}
time_rate
```

```{r}
#наше завдання розрахувати фактичну заплатню кожного співробітника за формулою total = rate * time_rate + bonus - penalty.

#Підсумковий код при правильному розрахунку матиме такий вигляд:
salary %>%
  rows_update(bonus, by = 'employee_id') %>% 
  rows_update(penalty, by = 'employee_id') %>% 
  rows_insert(new, by = 'employee_id') %>% 
  left_join(time_rate, by = 'employee_id') %>% 
  mutate(
    total = rate * time_rate + coalesce(bonus, 0) - coalesce(penalty, 0)
  ) %>%
  select(employee_id, rate, bonus, penalty, time_rate, total)
```

## Висновки

В цій лабораторній роботі ми розглядали різні задачі з використанням пакету dplyr в R, а також методи роботи з даними.

Ми дізналися, як використовувати функції select(), mutate(), summarise() та інші, щоб обробляти дані в таблицях.
